â˜• Java lÃ  ngÃ´n ngá»¯ láº­p trÃ¬nh hÆ°á»›ng Ä‘á»‘i tÆ°á»£ng
Má»™t trong nhá»¯ng lÃ½ do khiáº¿n Java trá»Ÿ nÃªn phá»• biáº¿n lÃ  vÃ¬ nÃ³ há»— trá»£ máº¡nh máº½ láº­p trÃ¬nh hÆ°á»›ng Ä‘á»‘i tÆ°á»£ng (OOP - Object-Oriented Programming). OOP giÃºp cho viá»‡c phÃ¡t triá»ƒn pháº§n má»m trá»Ÿ nÃªn:

ğŸ”¹ Dá»… quáº£n lÃ½
ğŸ”¹ Dá»… báº£o trÃ¬ vÃ  má»Ÿ rá»™ng
ğŸ”¹ TÃ¡i sá»­ dá»¥ng Ä‘Æ°á»£c mÃ£ nguá»“n

ğŸŒ± BÃªn cáº¡nh Ä‘Ã³, Java cÃ²n há»— trá»£ ráº¥t tá»‘t cÃ¡c framework mÃ£ nguá»“n má»Ÿ nhÆ° Spring, cho phÃ©p sá»­ dá»¥ng ká»¹ thuáº­t Dependency Injection (DI) â€“ giÃºp quáº£n lÃ½ tá»‘t hÆ¡n cÃ¡c Ä‘á»‘i tÆ°á»£ng phá»¥ thuá»™c, tÄƒng tÃ­nh linh hoáº¡t vÃ  dá»… kiá»ƒm thá»­.

1. Táº¡i sao nÃªn há»c Java?
Java ráº¥t dá»… tÃ¬m hiá»ƒu
Java lÃ  má»™t ngÃ´n ngá»¯ láº­p trÃ¬nh hÆ°á»›ng Ä‘á»‘i tÆ°á»£ng
TÃ i nguyÃªn Java Phong phÃº
CÃ´ng cá»¥ phÃ¡t triá»ƒn máº¡nh máº½
Kháº£ nÄƒng báº£o máº­t cá»§a Java ráº¥t cao
Java lÃ  ngÃ´n ngá»¯ láº­p trÃ¬nh miá»…n phÃ­
Há»— trá»£ tÃ i liá»‡u xuáº¥t sáº¯c => JavaDocs
Java lÃ  ná»n táº£ng Ä‘á»™c láº­p, cÃ³ thá»ƒ â€œviáº¿t má»™t láº§n cháº¡y má»i nÆ¡iâ€
Sá»± há»— trá»£ tá»« cá»™ng Ä‘á»“ng khá»•ng lá»“

-----------------------------------------------------------------------------------------------------------------

ğŸ§± Java cÃ²n khuyáº¿n khÃ­ch láº­p trÃ¬nh viÃªn Ã¡p dá»¥ng nguyÃªn táº¯c SOLID â€“ gá»“m 5 nguyÃªn táº¯c thiáº¿t káº¿ quan trá»ng trong OOP:

S â€“ Single Responsibility: Má»—i lá»›p chá»‰ nÃªn Ä‘áº£m nháº­n má»™t nhiá»‡m vá»¥ duy nháº¥t.

O â€“ Open/Closed Principle: Má»Ÿ rá»™ng Ä‘Æ°á»£c nhÆ°ng khÃ´ng sá»­a Ä‘á»•i mÃ£ gá»‘c.

L â€“ Liskov Substitution Principle: CÃ¡c lá»›p con cÃ³ thá»ƒ thay tháº¿ lá»›p cha mÃ  khÃ´ng lÃ m thay Ä‘á»•i tÃ­nh Ä‘Ãºng Ä‘áº¯n cá»§a chÆ°Æ¡ng trÃ¬nh.

I â€“ Interface Segregation Principle: Giao diá»‡n nÃªn nhá» gá»n, chuyÃªn biá»‡t.

D â€“ Dependency Inversion Principle: Phá»¥ thuá»™c vÃ o abstraction (trá»«u tÆ°á»£ng), khÃ´ng phá»¥ thuá»™c vÃ o chi tiáº¿t cá»¥ thá»ƒ.


1. âœ… Single Responsibility Principle (SRP)

ğŸ§  Äá»‹nh nghÄ©a:"A class should have only one reason to change."

Lá»›p chá»‰ nÃªn cÃ³ má»™t trÃ¡ch nhiá»‡m duy nháº¥t â€“ nghÄ©a lÃ  nÃ³ chá»‰ nÃªn xá»­ lÃ½ má»™t pháº§n viá»‡c trong há»‡ thá»‘ng.

âŒ VÃ­ dá»¥ sai:
public class Employee {
    public void calculateSalary() {
        // logic tÃ­nh lÆ°Æ¡ng
    }

    public void saveToDatabase() {
        // logic lÆ°u vÃ o database
    }
}
â†’ Lá»›p nÃ y vá»«a tÃ­nh lÆ°Æ¡ng, vá»«a lÆ°u vÃ o DB â†’ 2 trÃ¡ch nhiá»‡m.

âœ… CÃ¡ch Ä‘Ãºng:
public class SalaryCalculator {
    public void calculateSalary(Employee emp) {
        // tÃ­nh lÆ°Æ¡ng
    }
}

public class EmployeeRepository {
    public void save(Employee emp) {
        // lÆ°u vÃ o DB
    }
}

=> Náº¿u báº¡n lÃ  tÃ´i trong tÆ°Æ¡ng láº¡i khi Ä‘á»c láº¡i pháº§n nÃ y cÃ³ thá»ƒ sáº½ quÃªn vÃ  cáº£m tháº¥y vÃ´ lÃ½ vÃ  rÆ°á»m rÃ  khi má»—i method hÃ nh Ä‘á»™ng cá»§a Employee láº¡i tÃ¡ch thÃ nh cÃ¡c class nhÆ° tháº¿ nÃ y sáº½ khiáº¿n há»‡ thá»‘ng trá»Ÿ nÃªn vÃ´ cÃ¹ng phá»©c táº¡p, suy ra SRP lÃ  1 nguyÃªn táº¯c ráº¥t ngu.
- Tuy nhiÃªn nguyÃªn táº¯c nÃ y náº±m á»Ÿ 1 táº§m nhÃ¬n ráº¥t lá»›n. CÃ³ thá»ƒ hiá»ƒn lÃ  viá»‡c tÃ­nh KPI, TÃ­nh lÆ°Æ¡ng chá»‰ lÃ  1 method nhá» cÃ³ thá»ƒ Ä‘Æ°á»£c tÃ­nh lÃ  cÃ¡c hÃ nh Ä‘á»™ng lÃ m viá»‡c vá»›i Employee Ä‘á»ƒ nhÃ©t toÃ n bá»™ vÃ o 1 class. NhÆ°ng vá»›i 1 gÃ³c nhÃ¬n rá»™ng hÆ¡n váº¥n Ä‘á» liÃªn quan Ä‘áº¿n KPI ráº¥t lá»›n vÃ­ dá»¥: // Giáº£ sá»­ KPI tÃ­nh theo lÆ°Æ¡ng, Set KPI score based on performance review, Adjust KPI score based on manager's feedback, Review KPI for yearly performance,... LÃºc nÃ y KPI lá»›n tÆ°Æ¡ng Ä‘Æ°á»£c vá»›i 1 Ä‘á»‘i tÆ°á»£ng vÃ  xáº¿p ngÃ nh Employee -> NÃ³ cáº§n Ä‘Æ°á»£c tÃ¡ch riÃªng thÃ nh cÃ¡c class cÃ³ method riÃªng. TÆ°Æ¡ng tá»± vá»›i LÆ°Æ¡ng hay lÆ°u thÃ´ng tin vÃ o DB.

ğŸ”š ChÃ­nh vÃ¬ tháº¿ viá»‡c SRP cÃ³ Ä‘Ãºng hay khÃ´ng, cÃ³ cáº§n tÃ¡ch ra hay khÃ´ng cáº§n nhÃ¬n vÃ o gÃ³c nhÃ¬n, má»¥c Ä‘Ã­nh cá»§a ngÆ°á»i muá»‘n táº¡o ra web. Náº¿u nÃ³ nhá» thÃ¬ coi nhÆ° cÃ¡c method cá»§a 1 Entity, nhÆ°ng náº¿u nÃ³ Ä‘á»§ lá»›n thÃ¬ sáº½ trá»Ÿ thÃ nh 1 Entity riÃªng biá»‡t vá»›i cÃ¡c method vÃ  báº£ng lÆ°u trá»¯ trong DB. NÃªn cáº§n nháº­n Ä‘á»‹nh rÃµ "A class should have only one reason to change." "REASON" á»Ÿ Ä‘Ã¢y lÃ  gÃ¬, náº¿u nÃ³ Ä‘á»§ lá»›n thÃ¬ tÃ¡ch riÃªng Ä‘á»ƒ Ä‘áº£m báº£o SRP, cÃ²n khÃ´ng thÃ¬ hÃ£y gá»™p láº¡i Ä‘á»ƒ trÃ¡nh lÃ m há»‡ thá»‘ng bá»‹ rÆ°á»m rÃ  vÃ  cÃ²n khÃ³ Ä‘á»ƒ quáº£n lÃ½, báº£o trÃ¬, kiá»ƒm thá»­, má»Ÿ rá»™ng,...

-----------------------------------------------------------------------------------------------------------------

2. âœ… Open/Closed Principle (OCP)
ğŸ§  Äá»‹nh nghÄ©a:
"Software entities should be open for extension but closed for modification."

Báº¡n nÃªn má»Ÿ rá»™ng báº±ng cÃ¡ch thÃªm mÃ£ má»›i, thay vÃ¬ sá»­a mÃ£ cÅ©.

âŒ VÃ­ dá»¥ sai:
public class Payment {
    public void pay(String type) {
        if (type.equals("credit")) {
            // xá»­ lÃ½ thanh toÃ¡n qua tháº»
        } else if (type.equals("paypal")) {
            // xá»­ lÃ½ qua paypal
        }
    }
}
â†’ Má»—i khi thÃªm loáº¡i thanh toÃ¡n má»›i, báº¡n pháº£i sá»­a lá»›p nÃ y.

âœ… CÃ¡ch Ä‘Ãºng (sá»­ dá»¥ng interface):
public interface PaymentMethod {
    void pay();
}

public class CreditCard implements PaymentMethod {
    public void pay() {
        System.out.println("Thanh toÃ¡n báº±ng tháº»");
    }
}

public class PayPal implements PaymentMethod {
    public void pay() {
        System.out.println("Thanh toÃ¡n qua PayPal");
    }
}

public class Payment {
    public void pay(PaymentMethod method) {
        method.pay();
    }
}
=> Vá»›i má»—i yÃªu cáº§u má»Ÿ rá»™ng chá»‰ cáº§n thÃªm code má»›i, mÃ  k Ä‘á»¥ng vÃ o code cÅ© Ä‘áº£m báº£o viá»‡c má»Ÿ rá»™ng an toÃ n hiá»‡u quáº£

ğŸ‘‡ LÃ½ do chi tiáº¿t táº¡i sao cáº§n OCP:
Dá»… dÃ ng báº£o trÃ¬ vÃ  cáº­p nháº­t tÃ­nh nÄƒng
Giáº£m thiá»ƒu rá»§i ro
TÄƒng tÃ­nh linh hoáº¡t
Cáº£i thiá»‡n kháº£ nÄƒng tÃ¡i sá»­ dá»¥ng mÃ£
Há»— trá»£ lÃ m viá»‡c nhÃ³m vÃ  phÃ¢n cÃ´ng cÃ´ng viá»‡c hiá»‡u quáº£

ğŸš€NhÆ°á»£c Ä‘iá»ƒm
- Tuy nhiÃªn trong 1 class con chá»‰ Ä‘Æ°á»£c overide 1 method cá»§a class cha 1 láº§n, nÃªn náº¿u muá»‘n overide nhiá»u láº§n thÃ¬ cáº§n táº¡o nhiá»u class
- OCP yÃªu cáº§u kinh nghiá»‡m thá»±c táº¿ vÃ¬ báº¡n pháº£i cÃ³ kháº£ nÄƒng nháº­n Ä‘á»‹nh Ä‘Æ°á»£c ráº±ng má»™t phÆ°Æ¡ng thá»©c hoáº·c má»™t lá»›p sáº½ cáº§n má»Ÿ rá»™ng trong tÆ°Æ¡ng lai vÃ  thiáº¿t káº¿ nÃ³ theo cÃ¡ch cÃ³ thá»ƒ dá»… dÃ ng má»Ÿ rá»™ng mÃ  khÃ´ng thay Ä‘á»•i mÃ£ hiá»‡n táº¡i.
- Báº¡n cÃ³ thá»ƒ dá»… dÃ ng rÆ¡i vÃ o tÃ¬nh tráº¡ng "modification" (thay Ä‘á»•i) thay vÃ¬ "extension" (má»Ÿ rá»™ng).

ğŸ’¡Váº­y lÃ m sao Ä‘á»ƒ giáº£i quyáº¿t váº¥n Ä‘á» nÃ y?
- KhÃ´ng Ã¡p dá»¥ng OCP má»™t cÃ¡ch cá»©ng nháº¯c ngay tá»« Ä‘áº§u => Cá»© cáº¥u trÃºc dá»± Ã¡n vÃ  code sáº½ nháº­n ra nhá»¯ng pháº§n cáº§n má»Ÿ rá»™ng lÃºc nÃ y hÃ£y thiáº¿t káº¿ sao cho chÃºng dá»… dÃ ng má»Ÿ rá»™ng trong tÆ°Æ¡ng láº¡i thay vÃ¬ modification
- Sá»­ dá»¥ng Interfaces chá»‰ khi thá»±c sá»± cáº§n thiáº¿t => Interface thá»±c sá»± máº¡nh nhÆ°ng Ä‘á»«ng há»Ÿ cÃ¡i vÃ´ sá»­a interface Ä‘á»ƒ overide láº¡i mÃ  hÃ£y thá»­ nghÄ© vá» nhá»¯ng gÃ¬ báº¡n thá»±c sá»± cáº§n vÃ  liá»‡u báº¡n cÃ³ thá»ƒ tÃ¡i sá»­ dá»¥ng mÃ£ hiá»‡n táº¡i mÃ  khÃ´ng cáº§n thay Ä‘á»•i quÃ¡ nhiá»u.
- Khi báº¡n cáº§n pháº£i cung cáº¥p nhiá»u cÃ¡ch triá»ƒn khai cho má»™t phÆ°Æ¡ng thá»©c (nhÆ° getUserInfoById vÃ  getUserInfoByToken), báº¡n cÃ³ thá»ƒ táº¡o cÃ¡c lá»›p con thay vÃ¬ thÃªm phÆ°Æ¡ng thá»©c má»›i vÃ o trong interface.

-----------------------------------------------------------------------------------------------------------------

3. âœ… Liskov Substitution Principle (LSP)
ğŸ§  Äá»‹nh nghÄ©a:
"Objects of a superclass should be replaceable with objects of its subclasses."

Lá»›p con pháº£i cÃ³ thá»ƒ thay tháº¿ lá»›p cha mÃ  khÃ´ng lÃ m sai logic chÆ°Æ¡ng trÃ¬nh.

âŒ VÃ­ dá»¥ sai:
public class Bird {
    public void fly() {
        System.out.println("Bay lÃªn trá»i");
    }
}

public class Ostrich extends Bird {
    @Override
    public void fly() {
        throw new UnsupportedOperationException("ÄÃ  Ä‘iá»ƒu khÃ´ng bay Ä‘Æ°á»£c");
    }
}
â†’ Khi thay Bird báº±ng Ostrich thÃ¬ sáº½ phÃ¡t sinh lá»—i â†’ vi pháº¡m LSP.

âœ… CÃ¡ch Ä‘Ãºng:
public interface Bird {}

public interface FlyingBird extends Bird {
    void fly();
}

public class Sparrow implements FlyingBird {
    public void fly() {
        System.out.println("Chim sáº» bay");
    }
}

public class Ostrich implements Bird {
    // khÃ´ng bay, nÃªn khÃ´ng cáº§n implement fly
}


ğŸ”¹ extends (káº¿ thá»«a class):
ğŸ‘‰ "Káº¿ thá»«a Ä‘á»ƒ dÃ¹ng láº¡i"

DÃ¹ng khi báº¡n muá»‘n sá»­ dá»¥ng láº¡i logic cÃ³ sáºµn tá»« class cha.

ğŸ”¹ implements (triá»ƒn khai interface):
ğŸ‘‰ "Cam káº¿t Ä‘á»ƒ triá»ƒn khai"

DÃ¹ng khi class cam káº¿t pháº£i thá»±c hiá»‡n má»™t sá»‘ hÃ nh vi, nhÆ°ng interface khÃ´ng cÃ³ sáºµn logic.


ğŸ“Œ TÃ³m gá»n lá»i báº¡n nÃ³i báº±ng quy táº¯c:
"Náº¿u má»™t lá»›p con khÃ´ng thá»ƒ thá»±c hiá»‡n Ä‘áº§y Ä‘á»§ trÃ¡ch nhiá»‡m cá»§a lá»›p cha hoáº·c interface, thÃ¬ kiáº¿n trÃºc cáº§n Ä‘Æ°á»£c refactor (thiáº¿t káº¿ láº¡i)."

â†’ ÄÃ¢y lÃ  cÃ¡ch tuÃ¢n thá»§ LSP vÃ  chuáº©n bá»‹ tá»‘t cho Interface Segregation Principle (ISP) ná»¯a.

-----------------------------------------------------------------------------------------------------------------

4. âœ… Interface Segregation Principle (ISP)
ğŸ§  Äá»‹nh nghÄ©a:
"Clients should not be forced to depend on interfaces they do not use."

Giao diá»‡n nÃªn Ä‘Æ°á»£c chia nhá», thay vÃ¬ táº¡o má»™t interface khá»•ng lá»“ vá»›i nhiá»u chá»©c nÄƒng.

âŒ VÃ­ dá»¥ sai:
public interface Machine {
    void print();
    void scan();
    void fax();
}

public class OldPrinter implements Machine {
    public void print() { /* ok */ }
    public void scan() { throw new UnsupportedOperationException(); }
    public void fax() { throw new UnsupportedOperationException(); }
}
â†’ MÃ¡y in cÅ© chá»‰ in Ä‘Æ°á»£c, nhÆ°ng bá»‹ Ã©p pháº£i implement nhá»¯ng thá»© khÃ´ng cáº§n.

âœ… CÃ¡ch Ä‘Ãºng:
public interface Printer {
    void print();
}

public interface Scanner {
    void scan();
}

public class OldPrinter implements Printer {
    public void print() { /* ok */ }
}

ğŸš« LSP (Liskov Substitution Principle) â€“ Lá»—i cá»§a lá»›p con (subclass)
LSP lÃ  khi lá»›p con khÃ´ng thá»ƒ thay tháº¿ lá»›p cha má»™t cÃ¡ch Ä‘Ãºng Ä‘áº¯n.

Lá»›p con nháº­n nháº§m cha, nghÄ©a lÃ  lá»›p con khÃ´ng thá»ƒ thá»±c hiá»‡n chÃ­nh xÃ¡c hÃ nh vi cá»§a lá»›p cha vÃ  gÃ¢y ra lá»—i khi thay tháº¿ nÃ³.

Lá»—i do lá»›p con khÃ´ng Ä‘á»§ kháº£ nÄƒng Ä‘á»ƒ káº¿ thá»«a Ä‘Ãºng cÃ¡ch tá»« lá»›p cha.
ğŸ‘‰ Lá»—i cá»§a con: "Con khÃ´ng lÃ m Ä‘Æ°á»£c nhá»¯ng gÃ¬ cha Ä‘Ã£ lÃ m".



ğŸš« ISP (Interface Segregation Principle) â€“ Lá»—i cá»§a lá»›p cha (interface)
ISP lÃ  khi interface yÃªu cáº§u lá»›p con pháº£i thá»±c hiá»‡n quÃ¡ nhiá»u hÃ nh vi khÃ´ng cáº§n thiáº¿t, Ä‘iá»u nÃ y gÃ¢y ra sá»± lÃ£ng phÃ­ trong viá»‡c triá»ƒn khai.

Lá»›p cha/interface cÃ³ quÃ¡ nhiá»u yÃªu cáº§u khÃ´ng cáº§n thiáº¿t, khiáº¿n lá»›p con bá»‹ Ã©p pháº£i implement nhá»¯ng phÆ°Æ¡ng thá»©c mÃ  chÃºng khÃ´ng cáº§n dÃ¹ng.

Lá»—i do interface khÃ´ng phÃ¹ há»£p vá»›i yÃªu cáº§u cá»§a tá»«ng lá»›p con.
ğŸ‘‰ Lá»—i cá»§a cha: "Cha ká»³ vá»ng quÃ¡ nhiá»u á»Ÿ con".
-----------------------------------------------------------------------------------------------------------------

5. âœ… Dependency Inversion Principle (DIP)
ğŸ§  Äá»‹nh nghÄ©a:
"Depend on abstractions, not on concretions."

â†’ Lá»›p cao cáº¥p khÃ´ng nÃªn phá»¥ thuá»™c vÃ o lá»›p cá»¥ thá»ƒ, mÃ  nÃªn phá»¥ thuá»™c vÃ o interface (abstraction).

ğŸ“Œ Giáº£i thÃ­ch ngáº¯n gá»n:
High-level module (mÃ´-Ä‘un cáº¥p cao) lÃ  nhá»¯ng mÃ´-Ä‘un xá»­ lÃ½ cÃ¡c yÃªu cáº§u, cÃ¡c logic nghiá»‡p vá»¥ chÃ­nh cá»§a há»‡ thá»‘ng.

Low-level module (mÃ´-Ä‘un cáº¥p tháº¥p) lÃ  nhá»¯ng mÃ´-Ä‘un thá»±c thi cÃ¡c chi tiáº¿t cá»¥ thá»ƒ, cháº³ng háº¡n nhÆ° viá»‡c truy cáº­p cÆ¡ sá»Ÿ dá»¯ liá»‡u, gá»­i email, ghi log...

Abstraction lÃ  cÃ¡c interface hoáº·c abstract class mÃ  mÃ´-Ä‘un cáº¥p cao vÃ  cáº¥p tháº¥p Ä‘á»u pháº£i phá»¥ thuá»™c vÃ o.

ğŸ¯ Má»¥c tiÃªu chÃ­nh cá»§a DIP:
Giáº£m sá»± phá»¥ thuá»™c giá»¯a cÃ¡c mÃ´-Ä‘un (sá»± káº¿t ná»‘i cháº·t cháº½).

Táº¡o ra há»‡ thá»‘ng dá»… dÃ ng thay Ä‘á»•i, báº£o trÃ¬ mÃ  khÃ´ng cáº§n pháº£i thay Ä‘á»•i logic cá»§a cÃ¡c mÃ´-Ä‘un cáº¥p cao.

Dá»… dÃ ng thay tháº¿ cÃ¡c pháº§n cá»©ng, cÃ¡c thÆ° viá»‡n, cÃ¡c dá»‹ch vá»¥ mÃ  khÃ´ng lÃ m áº£nh hÆ°á»Ÿng Ä‘áº¿n cÃ¡c pháº§n khÃ¡c cá»§a há»‡ thá»‘ng.

âŒ VÃ­ dá»¥ vi pháº¡m DIP:
class EmailService {
    void sendEmail(String emailAddress, String message) {
        // code gá»­i email cá»¥ thá»ƒ
    }
}

class UserNotification {
    private EmailService emailService;

    public UserNotification() {
        emailService = new EmailService(); // High-level module phá»¥ thuá»™c trá»±c tiáº¿p vÃ o low-level module
    }

    void notifyUser(String emailAddress, String message) {
        emailService.sendEmail(emailAddress, message);
    }
}
â†’ Váº¥n Ä‘á»: UserNotification lÃ  mÃ´-Ä‘un cáº¥p cao nhÆ°ng láº¡i phá»¥ thuá»™c trá»±c tiáº¿p vÃ o EmailService (mÃ´-Ä‘un cáº¥p tháº¥p). Äiá»u nÃ y lÃ m cho há»‡ thá»‘ng khÃ´ng linh hoáº¡t vÃ  khÃ³ thay tháº¿ EmailService báº±ng má»™t dá»‹ch vá»¥ khÃ¡c (nhÆ° SMTP, hoáº·c SendGrid) mÃ  khÃ´ng thay Ä‘á»•i mÃ£ nguá»“n cá»§a UserNotification.


âœ… CÃ¡ch sá»­a theo DIP:
TÃ¡ch biá»‡t cÃ¡c mÃ´-Ä‘un phá»¥ thuá»™c vÃ o abstraction (interface)
interface MessageService {
    void sendMessage(String emailAddress, String message);
}

class EmailService implements MessageService {
    public void sendMessage(String emailAddress, String message) {
        // code gá»­i email cá»¥ thá»ƒ
    }
}

class UserNotification {
    private MessageService messageService;

    // Constructor injection (dependency injection)
    public UserNotification(MessageService messageService) {
        this.messageService = messageService;
    }

    void notifyUser(String emailAddress, String message) {
        messageService.sendMessage(emailAddress, message);
    }
}
â†’ Cáº£i tiáº¿n:

Giá» UserNotification khÃ´ng cÃ²n phá»¥ thuá»™c trá»±c tiáº¿p vÃ o EmailService. Thay vÃ o Ä‘Ã³, nÃ³ phá»¥ thuá»™c vÃ o má»™t interface MessageService.

ChÃºng ta cÃ³ thá»ƒ dá»… dÃ ng thay tháº¿ EmailService báº±ng báº¥t ká»³ dá»‹ch vá»¥ nÃ o khÃ¡c (vÃ­ dá»¥: SMSService, PushNotificationService) mÃ  khÃ´ng pháº£i thay Ä‘á»•i UserNotification.

ğŸ“Œ LÃ½ do cáº§n DIP:
TÃ­nh linh hoáº¡t: MÃ´-Ä‘un cáº¥p cao khÃ´ng phá»¥ thuá»™c vÃ o chi tiáº¿t cá»¥ thá»ƒ, vÃ¬ tháº¿ cÃ³ thá»ƒ thay tháº¿ chi tiáº¿t mÃ  khÃ´ng áº£nh hÆ°á»Ÿng Ä‘áº¿n há»‡ thá»‘ng.

TÃ­nh dá»… dÃ ng báº£o trÃ¬: Báº¡n cÃ³ thá»ƒ thay Ä‘á»•i chi tiáº¿t cá»¥ thá»ƒ (nhÆ° dá»‹ch vá»¥ gá»­i email) mÃ  khÃ´ng áº£nh hÆ°á»Ÿng Ä‘áº¿n cÃ¡c mÃ´-Ä‘un nghiá»‡p vá»¥.

Kiá»ƒm thá»­ dá»… dÃ ng: VÃ¬ cÃ¡c mÃ´-Ä‘un cáº¥p cao khÃ´ng phá»¥ thuá»™c trá»±c tiáº¿p vÃ o cÃ¡c chi tiáº¿t, báº¡n cÃ³ thá»ƒ dá»… dÃ ng mock hoáº·c thay tháº¿ cÃ¡c chi tiáº¿t khi viáº¿t unit test.

ğŸ’¡ Máº¹o nhá»› DIP:
MÃ´-Ä‘un cáº¥p cao khÃ´ng nÃªn biáº¿t vá» chi tiáº¿t (low-level modules), chÃºng chá»‰ nÃªn phá»¥ thuá»™c vÃ o interface hoáº·c abstract class.

Chi tiáº¿t (low-level) pháº£i phá»¥ thuá»™c vÃ o trá»«u tÆ°á»£ng (abstraction), khÃ´ng pháº£i ngÆ°á»£c láº¡i.