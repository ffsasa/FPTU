1ï¸âƒ£ TÃ¬m pháº§n tá»­ duy nháº¥t (khÃ´ng láº·p láº¡i)
ğŸ”¹ BÃ i toÃ¡n:
Cho má»™t máº£ng sá»‘ nguyÃªn nums, trong Ä‘Ã³ má»—i pháº§n tá»­ xuáº¥t hiá»‡n hai láº§n, ngoáº¡i trá»« má»™t pháº§n tá»­ duy nháº¥t. HÃ£y tÃ¬m pháº§n tá»­ Ä‘Ã³.
Input: nums = [4, 1, 2, 1, 2]
Output: 4

ğŸ”¹ RÃ ng buá»™c:
1 <= nums.length <= 10^5
-10^9 <= nums[i] <= 10^9
Chá»‰ cÃ³ má»™t pháº§n tá»­ duy nháº¥t, cÃ¡c pháº§n tá»­ khÃ¡c xuáº¥t hiá»‡n Ä‘Ãºng hai láº§n.
Äá»™ phá»©c táº¡p mong muá»‘n: O(n), khÃ´ng dÃ¹ng thÃªm bá»™ nhá»› náº¿u cÃ³ thá»ƒ.

ğŸ”¹ Gá»£i Ã½:
XOR (^) cÃ³ thá»ƒ giÃºp giáº£i bÃ i nÃ y má»™t cÃ¡ch tá»‘i Æ°u.

ğŸ”µBÃ i lÃ m:
Map<Integer, Integer> freq = new HashMap<>();
for (int num : arr) {
    freq.put(num, freq.getOrDefault(num, 0) + 1);
}
int mostFrequent = Collections.min(freq.entrySet(), Map.Entry.comparingByValue()).getKey();

ğŸ”¥Lá»—i: chá»‰ tÃ¬m ra sá»‘ cÃ³ chá»‰ sá»‘ tháº¥p nháº¥t k pháº£i = 1

ğŸŸ¢BÃ i giáº£i:
public int singleNumber(int[] arr) {
    int result = 0;
    for (int num : arr) {
        result ^= num; // XOR táº¥t cáº£ pháº§n tá»­
    }
    return result;
}

ğŸš€ XOR Ä‘Ã£ há»c tá»« ráº¥t lÃ¢u "^"
1ï¸âƒ£ Má»™t sá»‘ XOR vá»›i chÃ­nh nÃ³ = 0
A ^ A = 0
ğŸ‘‰ DÃ¹ng Ä‘á»ƒ loáº¡i bá» sá»‘ trÃ¹ng láº·p.

2ï¸âƒ£ Má»™t sá»‘ XOR vá»›i 0 khÃ´ng thay Ä‘á»•i
A ^ 0 = A
ğŸ‘‰ DÃ¹ng Ä‘á»ƒ khá»Ÿi táº¡o biáº¿n XOR.

3ï¸âƒ£ XOR cÃ³ tÃ­nh cháº¥t giao hoÃ¡n vÃ  káº¿t há»£p
A ^ B ^ C = C ^ B ^ A
=> Náº¿u cÃ³ A xuáº¥t hiá»‡n sá»‘ láº» láº§n, káº¿t quáº£ váº«n lÃ  A. Náº¿u A xuáº¥t hiá»‡n sá»‘ cháºµn láº§n, káº¿t quáº£ lÃ  0. A^A^A = A
=> K nháº§m láº«n XOR vá»›i MÅ©: Trong láº­p trÃ¬nh XOR lÃ  ^, MÅ© lÃ  Math.pow(a, b) a mÅ© b

-----------------------------------------------------------------------------------------------------------------

2ï¸âƒ£ TÃ¬m cáº·p sá»‘ cÃ³ tá»•ng báº±ng k
ğŸ”¹ BÃ i toÃ¡n:
Cho má»™t máº£ng nums gá»“m cÃ¡c sá»‘ nguyÃªn vÃ  má»™t sá»‘ k, hÃ£y tÃ¬m táº¥t cáº£ cÃ¡c cáº·p (a, b) sao cho a + b = k.

ğŸ”¹ VÃ­ dá»¥:
Input: nums = [2, 7, 11, 15], k = 9
Output: [[2,7]]

Input: nums = [3, 2, 4, 1, 6], k = 5
Output: [[3,2], [4,1]]

ğŸ”¹ RÃ ng buá»™c:
1 <= nums.length <= 10^5
-10^9 <= nums[i] <= 10^9
CÃ³ thá»ƒ cÃ³ nhiá»u hÆ¡n má»™t cáº·p thá»a mÃ£n.

ğŸ”¹ Gá»£i Ã½:
HashSet giÃºp tÃ¬m pháº§n tá»­ trong O(1).
Two pointers cÃ³ thá»ƒ Ä‘Æ°á»£c dÃ¹ng náº¿u máº£ng Ä‘Ã£ sáº¯p xáº¿p.

ğŸ”µBÃ i lÃ m:
List<List<Integer>> list = new ArrayList<>();
int[] nums = {3, 2, 4, 1, 6};
int k = 5;

for (int i = 0; i < nums.length; i++){
	for (int j = nums.length - 1; j > i ; j--){
		if(nums[i] + nums[j] == 5) {
			List<Integer> pair = new ArrayList<>();
            		pair.add(nums[i]);
            		pair.add(nums[j]);
            		list.add(pair);
		}
	}
}

return list;

âŒ NhÆ°á»£c Ä‘iá»ƒm:
KhÃ´ng dÃ¹ng Ä‘Æ°á»£c cho máº£ng lá»›n (vÃ­ dá»¥ 10^5 pháº§n tá»­).
CÃ³ thá»ƒ láº·p láº¡i cáº·p (a, b) náº¿u nums[i] vÃ  nums[j] giá»‘ng nhau hoáº·c cÃ³ thá»© tá»± khÃ¡c.

ğŸŸ¢BÃ i giáº£i:

List<List<Integer>> list = new ArrayList<>();
Set<Integer> seen = new HashSet<>();
Set<String> added = new HashSet<>(); // Äá»ƒ trÃ¡nh thÃªm cáº·p trÃ¹ng thá»© tá»±

for (int num : nums) {
    int complement = k - num;
    if (seen.contains(complement)) {
        // Sáº¯p xáº¿p cáº·p Ä‘á»ƒ trÃ¡nh thÃªm (3,2) vÃ  (2,3) lÃ  hai cáº·p khÃ¡c nhau
        int a = Math.min(num, complement);
        int b = Math.max(num, complement);
        String key = a + ":" + b;
        if (!added.contains(key)) {
            list.add(Arrays.asList(a, b));
            added.add(key);
        }
    }
    seen.add(num);
}
return list;

-----------------------------------------------------------------------------------------------------------------

3ï¸âƒ£ Sáº¯p xáº¿p máº£ng khÃ´ng dÃ¹ng thÆ° viá»‡n
ğŸ”¹ BÃ i toÃ¡n:
Viáº¿t má»™t hÃ m sáº¯p xáº¿p máº£ng nums theo thá»© tá»± tÄƒng dáº§n mÃ  khÃ´ng dÃ¹ng thÆ° viá»‡n cÃ³ sáºµn.

ğŸ”¹ VÃ­ dá»¥:
Input: nums = [5, 2, 9, 1, 5, 6]
Output: [1, 2, 5, 5, 6, 9]

ğŸ”¹ RÃ ng buá»™c:
1 <= nums.length <= 10^5
-10^9 <= nums[i] <= 10^9

ğŸ”¹ Gá»£i Ã½:
QuickSort (O(n log n)) lÃ  lá»±a chá»n tá»‘i Æ°u.
BubbleSort (O(nÂ²)) khÃ´ng tá»‘t vá»›i n lá»›n.

ğŸ”µBÃ i lÃ m:
private static int partition(int[] arr, int low, int high){
    int pi = arr[high];
    int i = low -1;

    for (int j = low; j<high; j++){
        if(arr[j]<pi){
            i++;
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    arr[high] = arr[i+1];
    arr[i+1] = pi;

    return i+1;
}

private static void quickSort(int[] arr, int low, int high){
    if(low<high){
        int pi = partition(arr, low, high);

        quickSort(arr, low, pi-1);
        quickSort(arr, pi+1, high);
    }
}

âŒ NhÆ°á»£c Ä‘iá»ƒm:
BÃ i bÃªn trÃªn pháº§n thay Ä‘á»•i vá»‹ trÃ­ cá»§a pivot lÃ  Ä‘Ãºng, nhÆ°ng trong trÆ°á»ng há»£p nÃ³ khÃ´ng pháº£i kiá»ƒu dá»¯ liá»‡u nguyÃªn thá»§y mÃ  lÃ  1 object thÃ¬ káº¿t quáº£ sáº½ lÃ  tham chiáº¿u chá»© khÃ´ng pháº£i copy. Náº¿u lÃ  copy thÃ¬ biáº¿n arr[high] thá»‹ thay Ä‘á»•i thÃ¬ pi khÃ´ng bá»‹ áº£nh hÆ°á»Ÿng gÃ¬. NhÆ°ng náº¿u lÃ  tham chiáº¿u thÃ¬ cáº£ 2 cÃ¹ng chá»‰ tá»›i 1 Ã´ nhá»› nÃªn 1 trong 2 bá»‹ thay Ä‘á»•i sáº½ áº£nh hÆ°á»Ÿng Ä‘áº¿n cÃ¡i cÃ²n láº¡i.
-----------------------------------------------------------------------------------------------------------------

4ï¸âƒ£ TÃ¬m máº£ng con cÃ³ tá»•ng lá»›n nháº¥t (Kadaneâ€™s Algorithm)
ğŸ”¹ BÃ i toÃ¡n:
Cho má»™t máº£ng sá»‘ nguyÃªn nums, tÃ¬m máº£ng con liÃªn tiáº¿p cÃ³ tá»•ng lá»›n nháº¥t.

ğŸ”¹ VÃ­ dá»¥:
Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
// Máº£ng con tá»‘i Æ°u: [4,-1,2,1] cÃ³ tá»•ng 6.

ğŸ”¹ RÃ ng buá»™c:
1 <= nums.length <= 10^5
-10^4 <= nums[i] <= 10^4

ğŸ”¹ Gá»£i Ã½:
Kadaneâ€™s Algorithm (O(n)) lÃ  cÃ¡ch tá»‘i Æ°u nháº¥t.

ğŸ”µBÃ i lÃ m:
public static int maxSubArray(int[] nums) {
    int currentSum = nums[0];
    int maxSum = nums[0];

    for (int i = 1; i < nums.length; i++) {
        currentSum = Math.max(nums[i], currentSum + nums[i]);
        maxSum = Math.max(maxSum, currentSum);
    }

    return maxSum;


-----------------------------------------------------------------------------------------------------------------

5ï¸âƒ£ TÃ¬m pháº§n tá»­ bá»‹ thiáº¿u trong dÃ£y 1-N
ğŸ”¹ BÃ i toÃ¡n:
Cho má»™t máº£ng nums chá»©a N-1 sá»‘ nguyÃªn tá»« 1 Ä‘áº¿n N. HÃ£y tÃ¬m sá»‘ bá»‹ thiáº¿u.

ğŸ”¹ VÃ­ dá»¥:
Input: nums = [3, 7, 1, 2, 8, 4, 5]
Output: 6

ğŸ”¹ RÃ ng buá»™c:
1 <= N <= 10^5
nums.length = N - 1
CÃ¡c sá»‘ trong nums lÃ  duy nháº¥t vÃ  náº±m trong pháº¡m vi [1, N].

ğŸ”¹ Gá»£i Ã½:
CÃ´ng thá»©c tá»•ng S = N * (N+1) / 2 giÃºp tÃ¬m sá»‘ bá»‹ thiáº¿u trong O(1).
XOR (^) cÃ³ thá»ƒ giÃºp giáº£i bÃ i nÃ y mÃ  khÃ´ng cáº§n cá»™ng dá»“n.

ğŸ”µBÃ i lÃ m:
int n = nums.length + 1;
int sumF = n*(n+1)/2;
int sum = 0;
for (int num : nums)
    sum += num;

return sumF- sum;

ğŸŸ¢BÃ i giáº£i:
public static int findMissing(int[] nums) {
    int xor1 = 0, xor2 = 0;
    int n = nums.length + 1;

    for (int i = 1; i <= n; i++) {
        xor1 ^= i;
    }

    for (int num : nums) {
        xor2 ^= num;
    }

    return xor1 ^ xor2;
}

CÃ¡ch 2 sáº½ trÃ´ng hay hÆ¡n :v